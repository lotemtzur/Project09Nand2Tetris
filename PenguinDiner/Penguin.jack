/** Implements the player-controlled penguin waitress */
class Penguin {
    field int x, y;           // position on screen
    field int size;           // size of the penguin sprite
    field int leftHandFood;   // food in left hand (-1=empty, 0=burger, 1=pizza, 2=fish)
    field int rightHandFood;  // food in right hand (-1=empty, 0=burger, 1=pizza, 2=fish)
    field int speedUpgrades;  // number of speed upgrades from shop
    field int moveCounter;    // counter for alternating speed bonus
    
    /** Constructs a new Penguin at given position */
    constructor Penguin new(int Ax, int Ay) {
        let x = Ax;
        let y = Ay;
        let size = 12;
        let leftHandFood = -1;   // -1 means empty
        let rightHandFood = -1;  // -1 means empty
        let speedUpgrades = 0;   // no upgrades initially
        let moveCounter = 0;     // start counter at 0
        do draw();
        return this;
    }
    
    /** Sets speed upgrades from shop */
    method void setSpeedUpgrades(int upgrades) {
        let speedUpgrades = upgrades;
        let moveCounter = 0;  // Reset counter when upgrades change
        return;
    }
    
    /** Calculates current movement step with upgrades */
    method int getMoveStep() {
        var int baseSpeed, extraSpeed;
        let baseSpeed = GameConfig.getBasePenguinSpeed();
        
        // Each upgrade adds 0.5 pixels on average by alternating between +0 and +1
        // moveCounter alternates: even moves get no bonus, odd moves get +1
        let extraSpeed = 0;
        if (speedUpgrades > 0) {
            // Increment counter
            let moveCounter = moveCounter + 1;
            
            // For each upgrade, check if this is an "on" move
            // If moveCounter is odd and we have upgrades, add the upgrades
            if ((moveCounter - ((moveCounter / 2) * 2)) = 1) {
                let extraSpeed = speedUpgrades;
            }
        }
        
        return baseSpeed + extraSpeed;
    }
    
    /** Disposes this penguin */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    /** Draws the penguin on screen */
    method void draw() {
        // Draw penguin body (black oval)
        do Screen.setColor(true);
        do Screen.drawCircle(x, y, 8);
        
        // Draw white belly
        do Screen.setColor(false);
        do Screen.drawCircle(x, y + 1, 5);
        
        // Draw black head
        do Screen.setColor(true);
        do Screen.drawCircle(x, y - 6, 5);
        
        // Draw white face
        do Screen.setColor(false);
        do Screen.drawCircle(x, y - 5, 3);
        
        // Draw eyes (black dots)
        do Screen.setColor(true);
        do Screen.drawRectangle(x - 2, y - 6, x - 1, y - 5);
        do Screen.drawRectangle(x + 1, y - 6, x + 2, y - 5);
        
        // Draw beak (orange-ish - small rectangle)
        do Screen.drawRectangle(x - 1, y - 4, x + 1, y - 3);
        
        // Draw feet (orange-ish - small rectangles)
        do Screen.drawRectangle(x - 5, y + 8, x - 3, y + 9);
        do Screen.drawRectangle(x + 3, y + 8, x + 5, y + 9);
        
        // Draw wings
        do Screen.drawRectangle(x - 9, y - 1, x - 7, y + 3);
        do Screen.drawRectangle(x + 7, y - 1, x + 9, y + 3);
        
        // Draw LEFT hand food
        if (~(leftHandFood = -1)) {
            do drawFoodInHand(x - 15, y - 2, leftHandFood);
        }
        
        // Draw RIGHT hand food
        if (~(rightHandFood = -1)) {
            do drawFoodInHand(x + 15, y - 2, rightHandFood);
        }
        
        return;
    }
    
    /** Draws a food item at specified position */
    method void drawFoodInHand(int foodX, int foodY, int foodType) {
        // Validate coordinates are within screen bounds
        if ((foodX < 5) | (foodX > 506)) { return; }
        if ((foodY < 0) | (foodY > 248)) { return; }
        
        do Screen.setColor(true);
        
        if (foodType = 0) {
            // Burger - small version
            do Screen.drawRectangle(foodX - 3, foodY, foodX + 3, foodY + 1);
            do Screen.drawRectangle(foodX - 3, foodY + 2, foodX + 3, foodY + 3);
            do Screen.drawRectangle(foodX - 3, foodY + 4, foodX + 3, foodY + 5);
        }
        
        if (foodType = 1) {
            // Pizza - small triangle
            do Screen.drawLine(foodX, foodY, foodX - 3, foodY + 5);
            do Screen.drawLine(foodX, foodY, foodX + 3, foodY + 5);
            do Screen.drawLine(foodX - 3, foodY + 5, foodX + 3, foodY + 5);
        }
        
        if (foodType = 2) {
            // Fish - small version
            do Screen.drawCircle(foodX, foodY + 2, 3);
            do Screen.drawLine(foodX - 3, foodY + 2, foodX - 5, foodY + 1);
            do Screen.drawLine(foodX - 3, foodY + 2, foodX - 5, foodY + 3);
        }
        
        return;
    }
    /** Erases the penguin from screen */
    method void erase() {
        do Screen.setColor(false);
        // Wider erase area to cover food in both hands
        do Screen.drawRectangle(x - 20, y - 12, x + 20, y + 10);
        return;
    }
    
    /** Moves penguin up - returns true if moved */
    method boolean moveUp(Array tables, int numTables, Array customers, int maxCustomers) {
        var int step, newY;
        let step = getMoveStep();
        let newY = y - step;
        if (newY > GameConfig.getPenguinMinY()) {
            do erase();
            let y = newY;
            return true;  // Signal that redrawAll is needed
        }
        return false;
    }
    
    /** Moves penguin down - returns true if moved */
    method boolean moveDown(Array tables, int numTables, Array customers, int maxCustomers) {
        var int step, newY;
        let step = getMoveStep();
        let newY = y + step;
        if (newY < GameConfig.getPenguinMaxY()) {
            do erase();
            let y = newY;
            return true;  // Signal that redrawAll is needed
        }
        return false;
    }
    
    /** Moves penguin left - returns true if moved */
    method boolean moveLeft(Array tables, int numTables, Array customers, int maxCustomers) {
        var int step, newX;
        let step = getMoveStep();
        let newX = x - step;
        if (newX > GameConfig.getPenguinMinX()) {
            do erase();
            let x = newX;
            return true;  // Signal that redrawAll is needed
        }
        return false;
    }
    
    /** Moves penguin right - returns true if moved */
    method boolean moveRight(Array tables, int numTables, Array customers, int maxCustomers) {
        var int step, newX;
        let step = getMoveStep();
        let newX = x + step;
        if (newX < GameConfig.getPenguinMaxX()) {
            do erase();
            let x = newX;
            return true;  // Signal that redrawAll is needed
        }
        return false;
    }
    
    /** Redraws tables and customers that are near the penguin's old position */
    method void redrawNearbyObjects(Array tables, int numTables, Array customers, int maxCustomers, int checkX, int checkY) {
        var int i, dx, dy;
        var Table table;
        var Customer customer;
        
        // Check if near kitchen (y around 230) - if so, redraw it
        // Kitchen is at bottom of screen, if penguin erased it, redraw
        if (checkY > 200) {
            // Penguin was near kitchen, need to redraw kitchen counter
            // We'll signal this needs full redraw by returning early
            // The calling code should handle kitchen redraw
        }
        
        // IMPORTANT: Draw tables FIRST (background layer)
        let i = 0;
        while (i < numTables) {
            let table = tables[i];
            let dx = table.getX() - checkX;
            let dy = table.getY() - checkY;
            
            if (dx < 0) { let dx = -dx; }
            if (dy < 0) { let dy = -dy; }
            
            // If table is within 50 pixels of where penguin was, redraw it
            if ((dx < 50) & (dy < 50)) {
                do table.draw();
            }
            
            let i = i + 1;
        }
        
        // Then draw customers (foreground layer)
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                let dx = customer.getX() - checkX;
                let dy = customer.getY() - checkY;
                
                if (dx < 0) { let dx = -dx; }
                if (dy < 0) { let dy = -dy; }
                
                // If customer is within 50 pixels of where penguin was, redraw it
                if ((dx < 50) & (dy < 50)) {
                    do customer.draw();
                }
            }
            
            let i = i + 1;
        }
        
        // CRITICAL: Draw food AFTER tables (separate pass to ensure visibility)
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                let dx = customer.getX() - checkX;
                let dy = customer.getY() - checkY;
                
                if (dx < 0) { let dx = -dx; }
                if (dy < 0) { let dy = -dy; }
                
                // If customer is within 50 pixels, draw their food
                if ((dx < 50) & (dy < 50)) {
                    do customer.drawFood();
                }
            }
            
            let i = i + 1;
        }
        return;
    }
    
    /** Gets X position */
    method int getX() {
        return x;
    }
    
    /** Gets Y position */
    method int getY() {
        return y;
    }
    
    /** Pick up order with food type (returns true if successful) */
    method boolean pickupOrder(int foodType) {
        // Try left hand first
        if (leftHandFood = -1) {
            let leftHandFood = foodType;
            do erase();
            do draw();
            return true;
        }
        
        // Then try right hand
        if (rightHandFood = -1) {
            let rightHandFood = foodType;
            do erase();
            do draw();
            return true;
        }
        
        // Both hands full!
        return false;
    }
    
    /** Deliver one order (delivers from right hand first, then left) */
    method void deliverOrder() {
        // Deliver from right hand first
        if (~(rightHandFood = -1)) {
            let rightHandFood = -1;
            do erase();
            do draw();
            return;
        }
        
        // Then left hand
        if (~(leftHandFood = -1)) {
            let leftHandFood = -1;
            do erase();
            do draw();
            return;
        }
        
        return;
    }
    
    /** Check if has any order */
    method boolean getHasOrder() {
        return (~(leftHandFood = -1)) | (~(rightHandFood = -1));
    }
    
    /** Check if both hands are full */
    method boolean bothHandsFull() {
        return (~(leftHandFood = -1)) & (~(rightHandFood = -1));
    }
    
    /** Get left hand food type */
    method int getLeftHandFood() {
        return leftHandFood;
    }
    
    /** Get right hand food type */
    method int getRightHandFood() {
        return rightHandFood;
    }
    
    /** Get the food type that will be delivered next (right hand priority) */
    method int getOrderType() {
        // Deliver from right hand first
        if (~(rightHandFood = -1)) {
            return rightHandFood;
        }
        
        // Then left hand
        if (~(leftHandFood = -1)) {
            return leftHandFood;
        }
        
        // No food in hands
        return -1;
    }
}
