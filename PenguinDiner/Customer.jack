/** Implements a customer penguin */
class Customer {
    field int x, y;              // position on screen
    field int state;             // 0=waiting, 1=seated, 2=ordered, 3=eating, 4=done
    field int patience;          // patience counter
    field int tableId;           // which table customer is at
    field int foodType;          // 0=burger, 1=pizza, 2=fish
    field int queuePosition;     // position in queue (0, 1, 2...)
    field Customer pair;         // partner customer if part of a pair (null if solo)
    field boolean isPairLeader;  // true if this is the main customer in a pair
    field boolean seatedOnLeft;  // true if seated on left side of table, false if right
    
    /** Constructs a new Customer at given position */
    constructor Customer new(int Ax, int Ay, int Atable) {
        let x = Ax;
        let y = Ay;
        let state = 0;
        let patience = GameConfig.getWaitingPatience();
        let tableId = Atable;
        let pair = null;  // Initialize as solo customer
        let isPairLeader = false;
        do draw();
        return this;
    }
    
    /** Disposes this customer */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    /** Draws the customer on screen */
    method void draw() {
        // Draw customer penguin body (smaller than player)
        do Screen.setColor(true);
        do Screen.drawCircle(x, y, 6);
        
        // Draw white belly
        do Screen.setColor(false);
        do Screen.drawCircle(x, y + 1, 4);
        
        // Draw black head
        do Screen.setColor(true);
        do Screen.drawCircle(x, y - 5, 4);
        
        // Draw white face
        do Screen.setColor(false);
        do Screen.drawCircle(x, y - 4, 2);
        
        // Draw eyes
        do Screen.setColor(true);
        do Screen.drawRectangle(x - 1, y - 5, x - 1, y - 4);
        do Screen.drawRectangle(x + 1, y - 5, x + 1, y - 4);
        
        // Draw beak
        do Screen.drawRectangle(x - 1, y - 3, x + 1, y - 2);
        
        // Draw feet
        do Screen.drawRectangle(x - 4, y + 6, x - 2, y + 7);
        do Screen.drawRectangle(x + 2, y + 6, x + 4, y + 7);
        
        // Draw indicator based on state
        if (state = 0) {
            // Waiting - draw exclamation mark
            do Screen.setColor(true);
            do Screen.drawRectangle(x + 8, y - 8, x + 9, y - 4);
            do Screen.drawRectangle(x + 8, y - 2, x + 9, y - 1);
        }
        if (state = 1) {
            // Seated - draw thinking bubble
            do Screen.setColor(true);
            do Screen.drawCircle(x + 9, y - 7, 3);
            do Screen.setColor(false);
            do Screen.drawCircle(x + 9, y - 7, 2);
        }
        if (state = 2) {
            // Ordered - draw food icon (burger)
            do Screen.setColor(true);
            do Screen.drawRectangle(x - 2, y - 10, x + 2, y - 8);
            do Screen.drawCircle(x, y - 12, 3);
        }
        // State 3 (eating) - food is drawn separately by drawFood() method, NOT here!
        // State 4 (done) - $ is drawn above table by Table class, NOT here!
        return;
    }
    /** Erases the customer from screen */
    method void erase() {
        var int x1, x2, y1, y2;
        
        do Screen.setColor(false);
        
        // Calculate erase bounds (extended to include food below table)
        let x1 = x - 26;
        let x2 = x + 26;
        let y1 = y - 15;
        let y2 = y + 18;
        
        // Clamp to screen bounds (0-511, 0-255)
        if (x1 < 0) { let x1 = 0; }
        if (x2 > 511) { let x2 = 511; }
        if (y1 < 0) { let y1 = 0; }
        if (y2 > 255) { let y2 = 255; }
        
        // Only erase if we have valid coordinates
        if ((x1 < x2) & (y1 < y2)) {
            do Screen.drawRectangle(x1, y1, x2, y2);
        }
        
        return;
    }
    
    /** Updates customer state */
    method void update() {
        var Customer partner;
        
        if (patience > 0) {
            let patience = patience - 1;
        }
        
        // Eating customers automatically finish when patience runs out
        if (state = 3) {
            if (patience < 1) {
                // If part of pair, check if partner is still eating (has patience > 1)
                // Use > 1 to avoid mutual waiting when both reach 0
                if (isPair()) {
                    let partner = getPair();
                    if (~(partner = null)) {
                        // Only wait if partner still actively eating (patience > 1, not just waiting)
                        if ((partner.getState() = 3) & (partner.getPatience() > 1)) {
                            let patience = 1;  // Keep at 1 to avoid going negative
                            return;  // Stay in eating state, don't transition yet
                        }
                    }
                }
                
                // Solo OR both in pair are done eating - transition to payment state
                let state = 4;
                let patience = GameConfig.getEatingDoneThreshold();
                do erase();
                do draw();
            }
        }
        return;
    }
    /** Check if both customers in pair are ready to pay */
    method boolean bothReadyToPay() {
        var Customer partner;
        var int partnerState;
        
        if (~isPair()) {
            return isReadyToLeave();  // Solo customer
        }
        
        // Check if both in pair are in state 4
        let partner = getPair();
        if (partner = null) {
            return isReadyToLeave();  // Partner was removed, treat as solo
        }
        
        // Safely get partner state
        let partnerState = partner.getState();
        
        return (state = 4) & (partnerState = 4);
    }
    
    /** Seat the customer */
    method void seat() {
        let state = 1;
        let patience = GameConfig.getSeatedPatience();
        do erase();
        do draw();
        return;
    }
    
    /** Take order from customer */
    method void takeOrder() {
        if (state = 1) {
            let state = 2;
            let patience = GameConfig.getOrderedPatience();
            do erase();
            do draw();
        }
        return;
    }
    
    /** Serve food to customer */
    method void serveFood() {
        if (state = 2) {
            let state = 3;
            let patience = GameConfig.getEatingTime();
            // Don't call erase/draw here - let redrawAll() handle it
        }
        return;
    }
    
    /** Collect payment */
    method int collectPayment() {
        var int tip;
        let tip = patience / GameConfig.getTipDivider();
        if (tip < GameConfig.getMinTip()) {
            let tip = GameConfig.getMinTip();
        }
        if (tip > GameConfig.getMaxTip()) {
            let tip = GameConfig.getMaxTip();
        }
        return tip;
    }
    
    /** Gets X position */
    method int getX() {
        return x;
    }
    
    /** Gets Y position */
    method int getY() {
        return y;
    }
    
    /** Gets state */
    method int getState() {
        return state;
    }
    
    /** Gets patience */
    method int getPatience() {
        return patience;
    }
    
    /** Moves customer to new position */
    method void moveTo(int newX, int newY) {
        do erase();
        let x = newX;
        let y = newY;
        return;
    }
    
    /** Check if customer is ready to leave */
    method boolean isReadyToLeave() {
        return state = 4;
    }
    
    /** Check if customer left angry */
    method boolean leftAngry() {
        return patience < 1;
    }
    
    /** Sets the food type customer ordered */
    method void setFoodType(int type) {
        let foodType = type;
        return;
    }
    
    /** Gets the food type */
    method int getFoodType() {
        return foodType;
    }
    
    /** Sets queue position */
    method void setQueuePosition(int pos) {
        let queuePosition = pos;
        return;
    }
    
    /** Gets queue position */
    method int getQueuePosition() {
        return queuePosition;
    }
    
    /** Sets this customer's pair partner */
    method void setPair(Customer partner) {
        let pair = partner;
        return;
    }
    
    /** Gets pair partner */
    method Customer getPair() {
        return pair;
    }
    
    /** Check if customer is part of a pair */
    method boolean isPair() {
        return ~(pair = null);
    }
    
    /** Sets if this customer is the pair leader */
    method void setIsPairLeader(boolean leader) {
        let isPairLeader = leader;
        return;
    }
    
    /** Check if this is the pair leader */
    method boolean getIsPairLeader() {
        return isPairLeader;
    }
    
    /** Sets which side of table customer is seated on */
    method void setSeatedOnLeft(boolean onLeft) {
        let seatedOnLeft = onLeft;
        return;
    }
    
    /** Draws only the food (for eating state) - called after tables are drawn */
    method void drawFood() {
        if (state = 3) {
            do Screen.setColor(true);
            
            if (seatedOnLeft) {
                // Seated on LEFT - food on RIGHT
                do Screen.drawCircle(x + 15, y, 6);
                do Screen.setColor(false);
                do Screen.drawCircle(x + 15, y, 5);
                do Screen.setColor(true);
                do Screen.drawCircle(x + 13, y - 1, 2);
                do Screen.drawCircle(x + 17, y, 2);
                do Screen.drawRectangle(x + 7, y - 2, x + 8, y + 2);
                do Screen.drawRectangle(x + 22, y - 2, x + 23, y + 2);
                do Screen.drawRectangle(x + 21, y - 2, x + 25, y - 1);
            } else {
                // Seated on RIGHT - food on LEFT
                do Screen.drawCircle(x - 15, y, 6);
                do Screen.setColor(false);
                do Screen.drawCircle(x - 15, y, 5);
                do Screen.setColor(true);
                do Screen.drawCircle(x - 17, y - 1, 2);
                do Screen.drawCircle(x - 13, y, 2);
                do Screen.drawRectangle(x - 23, y - 2, x - 22, y + 2);
                do Screen.drawRectangle(x - 25, y - 2, x - 21, y - 1);
                do Screen.drawRectangle(x - 8, y - 2, x - 7, y + 2);
            }
        }
        return;
    }
}
