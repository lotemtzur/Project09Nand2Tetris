/** Implements a customer penguin */
class Customer {
    field int x, y;              // position on screen
    field int state;             // 0=waiting, 1=seated, 2=ordered, 3=eating, 4=done
    field int patience;          // patience counter
    field int tableId;           // which table customer is at
    field int foodType;          // 0=burger, 1=pizza, 2=fish
    field int queuePosition;     // position in queue (0, 1, 2...)
    field Customer pair;         // partner customer if part of a pair (null if solo)
    field boolean isPairLeader;  // true if this is the main customer in a pair
    field boolean seatedOnLeft;  // true if seated on left side of table, false if right
    
    /** Constructs a new Customer at given position */
    constructor Customer new(int Ax, int Ay, int Atable) {
        let x = Ax;
        let y = Ay;
        let state = 0;
        let patience = GameConfig.getWaitingPatience();
        let tableId = Atable;
        let pair = null;  // Initialize as solo customer
        let isPairLeader = false;
        do draw();
        return this;
    }
    
    /** Disposes this customer */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    /** Draws the customer on screen */
    method void draw() {
        // Draw customer penguin body (smaller than player)
        do Screen.setColor(true);
        do Screen.drawCircle(x, y, 6);
        
        // Draw white belly
        do Screen.setColor(false);
        do Screen.drawCircle(x, y + 1, 4);
        
        // Draw black head
        do Screen.setColor(true);
        do Screen.drawCircle(x, y - 5, 4);
        
        // Draw white face
        do Screen.setColor(false);
        do Screen.drawCircle(x, y - 4, 2);
        
        // Draw eyes
        do Screen.setColor(true);
        do Screen.drawRectangle(x - 1, y - 5, x - 1, y - 4);
        do Screen.drawRectangle(x + 1, y - 5, x + 1, y - 4);
        
        // Draw beak
        do Screen.drawRectangle(x - 1, y - 3, x + 1, y - 2);
        
        // Draw feet
        do Screen.drawRectangle(x - 4, y + 6, x - 2, y + 7);
        do Screen.drawRectangle(x + 2, y + 6, x + 4, y + 7);
        
        // Draw state-specific icons
        if (state = 0) {
            // Waiting in queue - no state icon, just clock
        }
        if (state = 1) {
            // Seated, waiting to order - draw MENU icon
            do drawMenu(x + 10, y - 8);
        }
        if (state = 2) {
            // Ordered, waiting for food - draw FORK icon
            do drawFork(x + 10, y - 8);
        }
        // State 3 (eating) - food is drawn separately by drawFood() method
        // State 4 (done) - $ is drawn above table by Table class
        
        // Draw CLOCK icon only when patience is low (NOT for eating state 3)
        if (((state > -1) & (state < 3)) | (state = 4)) {
            if (shouldShowClock()) {
                do drawClock(x - 10, y - 8);
            }
        }
        return;
    }
    /** Erases the customer from screen */
    method void erase() {
        var int x1, x2, y1, y2;
        
        do Screen.setColor(false);
        
        // Calculate erase bounds (extended to include food below table)
        let x1 = x - 26;
        let x2 = x + 26;
        let y1 = y - 15;
        let y2 = y + 18;
        
        // Clamp to screen bounds (0-511, 0-255)
        if (x1 < 0) { let x1 = 0; }
        if (x2 > 511) { let x2 = 511; }
        if (y1 < 0) { let y1 = 0; }
        if (y2 > 255) { let y2 = 255; }
        
        // Only erase if we have valid coordinates
        if ((x1 < x2) & (y1 < y2)) {
            do Screen.drawRectangle(x1, y1, x2, y2);
        }
        
        return;
    }
    
    /** Updates customer state */
    method void update() {
        var Customer partner;
        var boolean waitingForPartner;
        
        let waitingForPartner = false;
        
        // Check if we're waiting for partner to finish eating (state 3)
        if (state = 3) {
            if (patience < 2) {  // About to finish eating
                if (isPair()) {
                    let partner = getPair();
                    if (~(partner = null)) {
                        // Check if we should wait for partner
                        if (partner.getState() = 3) {
                            if (partner.getPatience() > 1) {
                                let waitingForPartner = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Check if we're waiting for partner to transition to state 4 (payment)
        if (state = 4) {
            if (isPair()) {
                let partner = getPair();
                if (~(partner = null)) {
                    // If partner still eating (state 3), freeze our payment patience
                    if (partner.getState() = 3) {
                        let waitingForPartner = true;
                    }
                }
            }
        }
        
        // Only decrement patience if NOT waiting for partner
        if (~waitingForPartner) {
            if (patience > 0) {
                let patience = patience - 1;
            }
        }
        
        // Eating customers automatically finish when patience runs out
        if (state = 3) {
            if (patience < 1) {
                // If part of pair, check partner's state before transitioning
                if (isPair()) {
                    let partner = getPair();
                    if (~(partner = null)) {
                        // Wait if partner is STILL eating (state 3) with MORE patience remaining
                        if (partner.getState() = 3) {
                            if (partner.getPatience() > 1) {
                                return;  // Stay in eating state, wait for partner (patience frozen)
                            }
                        }
                    }
                }
                
                // Solo OR both in pair finished eating - transition to payment state
                let state = 4;
                let patience = GameConfig.getPaymentPatience();
                do erase();
                do draw();
            }
        }
        return;
    }
    /** Check if both customers in pair are ready to pay */
    method boolean bothReadyToPay() {
        var Customer partner;
        var int partnerState;
        
        if (~isPair()) {
            return isReadyToLeave();  // Solo customer
        }
        
        // Check if both in pair are in state 4
        let partner = getPair();
        if (partner = null) {
            return false;  // Partner was removed or doesn't exist - NOT ready
        }
        
        // Safely get partner state
        let partnerState = partner.getState();
        
        // Both must be in state 4
        return (state = 4) & (partnerState = 4);
    }
    
    /** Seat the customer */
    method void seat() {
        let state = 1;
        let patience = GameConfig.getSeatedPatience();
        do erase();
        do draw();
        return;
    }
    
    /** Take order from customer */
    method void takeOrder() {
        if (state = 1) {
            let state = 2;
            let patience = GameConfig.getOrderedPatience();
            do erase();
            do draw();
        }
        return;
    }
    
    /** Serve food to customer */
    method void serveFood() {
        if (state = 2) {
            let state = 3;
            let patience = GameConfig.getEatingPatience();
            do erase();
            do draw();  // Redraw to remove fork icon
        }
        return;
    }
    
    /** Collect payment */
    method int collectPayment() {
        var int tip;
        let tip = patience / GameConfig.getTipDivider();
        if (tip < GameConfig.getMinTip()) {
            let tip = GameConfig.getMinTip();
        }
        if (tip > GameConfig.getMaxTip()) {
            let tip = GameConfig.getMaxTip();
        }
        return tip;
    }
    
    /** Gets X position */
    method int getX() {
        return x;
    }
    
    /** Gets Y position */
    method int getY() {
        return y;
    }
    
    /** Gets state */
    method int getState() {
        return state;
    }
    
    /** Gets patience */
    method int getPatience() {
        return patience;
    }
    
    /** Moves customer to new position */
    method void moveTo(int newX, int newY) {
        do erase();
        let x = newX;
        let y = newY;
        return;
    }
    
    /** Check if customer is ready to leave */
    method boolean isReadyToLeave() {
        return state = 4;
    }
    
    /** Check if customer left angry */
    method boolean leftAngry() {
        return patience < 1;
    }
    
    /** Sets the food type customer ordered */
    method void setFoodType(int type) {
        let foodType = type;
        return;
    }
    
    /** Gets the food type */
    method int getFoodType() {
        return foodType;
    }
    
    /** Sets queue position */
    method void setQueuePosition(int pos) {
        let queuePosition = pos;
        return;
    }
    
    /** Gets queue position */
    method int getQueuePosition() {
        return queuePosition;
    }
    
    /** Sets this customer's pair partner */
    method void setPair(Customer partner) {
        let pair = partner;
        return;
    }
    
    /** Gets pair partner */
    method Customer getPair() {
        return pair;
    }
    
    /** Check if customer is part of a pair */
    method boolean isPair() {
        return ~(pair = null);
    }
    
    /** Sets if this customer is the pair leader */
    method void setIsPairLeader(boolean leader) {
        let isPairLeader = leader;
        return;
    }
    
    /** Check if this is the pair leader */
    method boolean getIsPairLeader() {
        return isPairLeader;
    }
    
    /** Sets which side of table customer is seated on */
    method void setSeatedOnLeft(boolean onLeft) {
        let seatedOnLeft = onLeft;
        return;
    }
    
    /** Draws only the food (for eating state) - called after tables are drawn */
    method void drawFood() {
        if (state = 3) {
            do Screen.setColor(true);
            
            if (seatedOnLeft) {
                // Seated on LEFT - food on RIGHT
                do Screen.drawCircle(x + 15, y, 6);
                do Screen.setColor(false);
                do Screen.drawCircle(x + 15, y, 5);
                do Screen.setColor(true);
                do Screen.drawCircle(x + 13, y - 1, 2);
                do Screen.drawCircle(x + 17, y, 2);
                do Screen.drawRectangle(x + 7, y - 2, x + 8, y + 2);
                do Screen.drawRectangle(x + 22, y - 2, x + 23, y + 2);
                do Screen.drawRectangle(x + 21, y - 2, x + 25, y - 1);
            } else {
                // Seated on RIGHT - food on LEFT
                do Screen.drawCircle(x - 15, y, 6);
                do Screen.setColor(false);
                do Screen.drawCircle(x - 15, y, 5);
                do Screen.setColor(true);
                do Screen.drawCircle(x - 17, y - 1, 2);
                do Screen.drawCircle(x - 13, y, 2);
                do Screen.drawRectangle(x - 23, y - 2, x - 22, y + 2);
                do Screen.drawRectangle(x - 25, y - 2, x - 21, y - 1);
                do Screen.drawRectangle(x - 8, y - 2, x - 7, y + 2);
            }
        }
        return;
    }
    
    /** Checks if clock should be shown (last 10 seconds of patience) */
    method boolean shouldShowClock() {
        // Show clock when patience drops below 10 seconds (250 cycles at 40ms loop)
        // 10 seconds = 10000ms / 40ms = 250 cycles
        return patience < 251;  // Less than 251 means 250 or fewer cycles remaining
    }
    
    /** Draws a CLOCK icon to represent patience */
    method void drawClock(int clockX, int clockY) {
        do Screen.setColor(true);
        
        // Draw clock circle (outline)
        do Screen.drawCircle(clockX, clockY, 4);
        
        // Draw white interior
        do Screen.setColor(false);
        do Screen.drawCircle(clockX, clockY, 3);
        
        // Draw clock hands (black lines)
        do Screen.setColor(true);
        
        // Hour hand - pointing up (12 o'clock position)
        do Screen.drawLine(clockX, clockY, clockX, clockY - 2);
        
        // Minute hand - pointing right (3 o'clock position)
        do Screen.drawLine(clockX, clockY, clockX + 2, clockY);
        
        return;
    }
    
    /** Draws a MENU icon (waiting to order) */
    method void drawMenu(int menuX, int menuY) {
        do Screen.setColor(true);
        
        // Draw menu rectangle (paper outline)
        do Screen.drawRectangle(menuX - 3, menuY - 4, menuX + 3, menuY + 4);
        
        // Draw white interior
        do Screen.setColor(false);
        do Screen.drawRectangle(menuX - 2, menuY - 3, menuX + 2, menuY + 3);
        
        // Draw text lines (black horizontal lines)
        do Screen.setColor(true);
        do Screen.drawLine(menuX - 2, menuY - 2, menuX + 2, menuY - 2);
        do Screen.drawLine(menuX - 2, menuY, menuX + 2, menuY);
        do Screen.drawLine(menuX - 2, menuY + 2, menuX + 2, menuY + 2);
        
        return;
    }
    
    /** Draws a FORK icon (waiting for food) */
    method void drawFork(int forkX, int forkY) {
        do Screen.setColor(true);
        
        // Draw handle (vertical line down the center)
        do Screen.drawLine(forkX, forkY + 1, forkX, forkY + 6);
        
        // Draw crossbar (horizontal line at top of handle)
        do Screen.drawLine(forkX - 2, forkY, forkX + 2, forkY);
        
        // Draw tines (3 vertical lines extending up from crossbar)
        // Left tine
        do Screen.drawLine(forkX - 2, forkY, forkX - 2, forkY - 3);
        
        // Middle tine
        do Screen.drawLine(forkX, forkY, forkX, forkY - 3);
        
        // Right tine
        do Screen.drawLine(forkX + 2, forkY, forkX + 2, forkY - 3);
        
        return;
    }
}
