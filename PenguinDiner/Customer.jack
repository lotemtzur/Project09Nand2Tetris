/** Implements a customer penguin */
class Customer {
    field int x, y;              // position on screen (center position for pairs)
    field int state;             // 0=waiting, 1=seated, 2=ordered, 3=eating, 4=done
    field int patience;          // patience counter
    field int tableId;           // which table customer is at
    field int queuePosition;     // position in queue (0, 1, 2...)
    field boolean isPair;        // true if this is a pair customer, false if solo
    field boolean sitsOnLeft;    // for solo: true if sits on left chair, false if right
    
    // Solo customer fields
    field int foodType;          // 0=burger, 1=pizza, 2=fish (for solo)
    
    // Pair customer fields
    field int foodType1;         // food for left penguin
    field int foodType2;         // food for right penguin
    field boolean meal1Served;   // true if first meal delivered
    field boolean meal2Served;   // true if second meal delivered
    
    /** Constructs a new solo Customer at given position */
    constructor Customer new(int Ax, int Ay, int Atable, boolean isAPair) {
        let x = Ax;
        let y = Ay;
        let state = 0;
        let patience = GameConfig.getWaitingPatience();
        let tableId = Atable;
        let isPair = isAPair;
        let meal1Served = false;
        let meal2Served = false;
        let sitsOnLeft = true;  // Default, will be set when seated
        do draw();
        return this;
    }
    
    /** Disposes this customer */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    /** Draws the customer on screen */
    method void draw() {
        if (isPair) {
            do drawPairPenguins();
        } else {
            do drawSinglePenguin(x, y);
        }
        
        // Draw state-specific icons
        if (state = 1) {
            // Seated, waiting to order - draw MENU icon
            if (isPair) {
                do drawMenu(x, y - 8);  // Center for pair
            } else {
                do drawMenu(x + 10, y - 8);
            }
        }
        if (state = 2) {
            // Ordered, waiting for food - draw FORK icon
            if (isPair) {
                do drawFork(x, y - 8);  // Center for pair
            } else {
                do drawFork(x + 10, y - 8);
            }
        }
        
        // Draw CLOCK icon only when patience is low (NOT for eating state 3)
        if (((state > -1) & (state < 3)) | (state = 4)) {
            if (shouldShowClock()) {
                if (isPair) {
                    do drawClock(x, y - 15);  // Above pair
                } else {
                    do drawClock(x - 10, y - 8);
                }
            }
        }
        return;
    }
    
    /** Draws a single penguin at specified position */
    method void drawSinglePenguin(int px, int py) {
        // Draw customer penguin body (smaller than player)
        do Screen.setColor(true);
        do Screen.drawCircle(px, py, 6);
        
        // Draw white belly
        do Screen.setColor(false);
        do Screen.drawCircle(px, py + 1, 4);
        
        // Draw black head
        do Screen.setColor(true);
        do Screen.drawCircle(px, py - 5, 4);
        
        // Draw white face
        do Screen.setColor(false);
        do Screen.drawCircle(px, py - 4, 2);
        
        // Draw eyes
        do Screen.setColor(true);
        do Screen.drawRectangle(px - 1, py - 5, px - 1, py - 4);
        do Screen.drawRectangle(px + 1, py - 5, px + 1, py - 4);
        
        // Draw beak
        do Screen.drawRectangle(px - 1, py - 3, px + 1, py - 2);
        
        // Draw feet
        do Screen.drawRectangle(px - 4, py + 6, px - 2, py + 7);
        do Screen.drawRectangle(px + 2, py + 6, px + 4, py + 7);
        
        return;
    }
    
    /** Draws pair penguins (two penguins side by side) */
    method void drawPairPenguins() {
        var int spacing;
        
        // Spacing depends on state: closer in queue, further apart when seated
        if (state = 0) {
            // In queue - stand closer together
            let spacing = 10;
        } else {
            // Seated at table - sit on chairs (further apart)
            let spacing = 20;
        }
        
        // Draw left penguin
        do drawSinglePenguin(x - spacing, y);
        
        // Draw right penguin
        do drawSinglePenguin(x + spacing, y);
        
        return;
    }
    /** Erases the customer from screen */
    method void erase() {
        var int x1, x2, y1, y2;
        
        do Screen.setColor(false);
        
        // Calculate erase bounds (extended to include clock, food, and pairs)
        if (isPair) {
            // Wider bounds for pairs (includes both penguins + meals on sides)
            let x1 = x - 45;
            let x2 = x + 45;
            let y1 = y - 20;  // Extended up for clock above pair
        } else {
            // Solo needs space for clock on left (x-10) and icons on right
            let x1 = x - 16;  // Extended left for clock
            let x2 = x + 26;
            let y1 = y - 15;
        }
        let y2 = y + 18;
        
        // Clamp to screen bounds (0-511, 0-255)
        if (x1 < 0) { let x1 = 0; }
        if (x2 > 511) { let x2 = 511; }
        if (y1 < 0) { let y1 = 0; }
        if (y2 > 255) { let y2 = 255; }
        
        // Only erase if we have valid coordinates
        if ((x1 < x2) & (y1 < y2)) {
            do Screen.drawRectangle(x1, y1, x2, y2);
        }
        
        return;
    }
    
    /** Updates customer state */
    method void update() {
        // Decrement patience
        if (patience > 0) {
            let patience = patience - 1;
        }
        
        // Eating customers automatically finish when patience runs out
        if (state = 3) {
            if (patience < 1) {
                let state = 4;
                let patience = GameConfig.getPaymentPatience();
                do erase();
                do draw();
            }
        }
        return;
    }
    
    /** Seat the customer */
    method void seat() {
        let state = 1;
        let patience = GameConfig.getSeatedPatience();
        do erase();
        do draw();
        return;
    }
    
    /** Take order from customer */
    method void takeOrder() {
        if (state = 1) {
            let state = 2;
            let patience = GameConfig.getOrderedPatience();
            do erase();
            do draw();
        }
        return;
    }
    
    /** Serve food to customer (for solo) or to specific position for pair */
    method void serveFood(int mealNumber) {
        if (state = 2) {
            if (isPair) {
                // For pairs, mark which meal was served
                if (mealNumber = 1) {
                    let meal1Served = true;
                } else {
                    let meal2Served = true;
                }
                
                // Only transition to eating when BOTH meals served
                if (meal1Served & meal2Served) {
                    let state = 3;
                    let patience = GameConfig.getEatingPatience();
                    do erase();
                    do draw();
                }
            } else {
                // Solo customer - immediate transition
                let state = 3;
                let patience = GameConfig.getEatingPatience();
                do erase();
                do draw();
            }
        }
        return;
    }
    
    /** Collect payment */
    method int collectPayment() {
        var int tip;
        let tip = patience / GameConfig.getTipDivider();
        if (tip < GameConfig.getMinTip()) {
            let tip = GameConfig.getMinTip();
        }
        if (tip > GameConfig.getMaxTip()) {
            let tip = GameConfig.getMaxTip();
        }
        return tip;
    }
    
    /** Gets X position */
    method int getX() {
        return x;
    }
    
    /** Gets Y position */
    method int getY() {
        return y;
    }
    
    /** Gets state */
    method int getState() {
        return state;
    }
    
    /** Gets patience */
    method int getPatience() {
        return patience;
    }
    
    /** Moves customer to new position */
    method void moveTo(int newX, int newY) {
        do erase();
        let x = newX;
        let y = newY;
        return;
    }
    
    /** Check if customer is ready to leave */
    method boolean isReadyToLeave() {
        return state = 4;
    }
    
    /** Check if customer left angry */
    method boolean leftAngry() {
        return patience < 1;
    }
    
    /** Sets the food type customer ordered (solo or pair meal 1) */
    method void setFoodType(int type) {
        if (isPair) {
            let foodType1 = type;
        } else {
            let foodType = type;
        }
        return;
    }
    
    /** Sets the second food type for pair */
    method void setFoodType2(int type) {
        if (isPair) {
            let foodType2 = type;
        }
        return;
    }
    
    /** Gets the food type (solo or pair meal 1) */
    method int getFoodType() {
        if (isPair) {
            return foodType1;
        }
        return foodType;
    }
    
    /** Gets the second food type for pair */
    method int getFoodType2() {
        if (isPair) {
            return foodType2;
        }
        return -1;
    }
    
    /** Check if customer is a pair */
    method boolean getIsPair() {
        return isPair;
    }
    
    /** Check if meal 1 is served (for pairs) */
    method boolean isMeal1Served() {
        return meal1Served;
    }
    
    /** Check if meal 2 is served (for pairs) */
    method boolean isMeal2Served() {
        return meal2Served;
    }
    
    /** Set which side solo customer sits on */
    method void setSitsOnLeft(boolean onLeft) {
        let sitsOnLeft = onLeft;
        return;
    }
    
    /** Sets queue position */
    method void setQueuePosition(int pos) {
        let queuePosition = pos;
        return;
    }
    
    /** Gets queue position */
    method int getQueuePosition() {
        return queuePosition;
    }
    
    
    /** Draws only the food (for eating state) - called after tables are drawn */
    method void drawFood() {
        if (isPair) {
            // For pairs in state 2 or 3, draw served meals ON THE TABLE (center)
            if ((state = 2) | (state = 3)) {
                if (meal1Served) {
                    do drawMealAtPosition(x - 8, y);  // Left meal on table
                }
                if (meal2Served) {
                    do drawMealAtPosition(x + 8, y);  // Right meal on table
                }
            }
        } else {
            // Solo customer - only draw food when eating ON THE TABLE (opposite side)
            if (state = 3) {
                if (sitsOnLeft) {
                    // Sits on left, food on right side of table
                    do drawMealAtPosition(x + 8, y);
                } else {
                    // Sits on right, food on left side of table
                    do drawMealAtPosition(x - 8, y);
                }
            }
        }
        return;
    }
    
    /** Draws a meal at specified position */
    method void drawMealAtPosition(int mealX, int mealY) {
        do Screen.setColor(true);
        do Screen.drawCircle(mealX, mealY, 6);
        do Screen.setColor(false);
        do Screen.drawCircle(mealX, mealY, 5);
        do Screen.setColor(true);
        do Screen.drawCircle(mealX - 2, mealY - 1, 2);
        do Screen.drawCircle(mealX + 2, mealY, 2);
        do Screen.drawRectangle(mealX - 8, mealY - 2, mealX - 7, mealY + 2);
        do Screen.drawRectangle(mealX + 7, mealY - 2, mealX + 8, mealY + 2);
        do Screen.drawRectangle(mealX + 6, mealY - 2, mealX + 10, mealY - 1);
        return;
    }
    
    /** Checks if clock should be shown (last 10 seconds of patience) */
    method boolean shouldShowClock() {
        // Show clock when patience drops below 10 seconds (250 cycles at 40ms loop)
        // 10 seconds = 10000ms / 40ms = 250 cycles
        return patience < 251;  // Less than 251 means 250 or fewer cycles remaining
    }
    
    /** Draws a CLOCK icon to represent patience */
    method void drawClock(int clockX, int clockY) {
        do Screen.setColor(true);
        
        // Draw clock circle (outline)
        do Screen.drawCircle(clockX, clockY, 4);
        
        // Draw white interior
        do Screen.setColor(false);
        do Screen.drawCircle(clockX, clockY, 3);
        
        // Draw clock hands (black lines)
        do Screen.setColor(true);
        
        // Hour hand - pointing up (12 o'clock position)
        do Screen.drawLine(clockX, clockY, clockX, clockY - 2);
        
        // Minute hand - pointing right (3 o'clock position)
        do Screen.drawLine(clockX, clockY, clockX + 2, clockY);
        
        return;
    }
    
    /** Draws a MENU icon (waiting to order) */
    method void drawMenu(int menuX, int menuY) {
        do Screen.setColor(true);
        
        // Draw menu rectangle (paper outline)
        do Screen.drawRectangle(menuX - 3, menuY - 4, menuX + 3, menuY + 4);
        
        // Draw white interior
        do Screen.setColor(false);
        do Screen.drawRectangle(menuX - 2, menuY - 3, menuX + 2, menuY + 3);
        
        // Draw text lines (black horizontal lines)
        do Screen.setColor(true);
        do Screen.drawLine(menuX - 2, menuY - 2, menuX + 2, menuY - 2);
        do Screen.drawLine(menuX - 2, menuY, menuX + 2, menuY);
        do Screen.drawLine(menuX - 2, menuY + 2, menuX + 2, menuY + 2);
        
        return;
    }
    
    /** Draws a FORK icon (waiting for food) */
    method void drawFork(int forkX, int forkY) {
        do Screen.setColor(true);
        
        // Draw handle (vertical line down the center)
        do Screen.drawLine(forkX, forkY + 1, forkX, forkY + 6);
        
        // Draw crossbar (horizontal line at top of handle)
        do Screen.drawLine(forkX - 2, forkY, forkX + 2, forkY);
        
        // Draw tines (3 vertical lines extending up from crossbar)
        // Left tine
        do Screen.drawLine(forkX - 2, forkY, forkX - 2, forkY - 3);
        
        // Middle tine
        do Screen.drawLine(forkX, forkY, forkX, forkY - 3);
        
        // Right tine
        do Screen.drawLine(forkX + 2, forkY, forkX + 2, forkY - 3);
        
        return;
    }
}
