/** Implements the Penguin Diner game logic */
class PenguinDinerGame {
    field Penguin penguin;       // the player penguin
    field Array tables;          // array of tables
    field Array customers;       // array of customers
    field Kitchen kitchen;       // the kitchen counter
    field int numTables;         // number of tables
    field int numCustomers;      // current number of ACTIVE customers
    field int maxCustomers;      // maximum customers at once
    field int totalCustomersServed; // total customers served (lifetime)
    field int score;             // player's money earned this level
    field int level;             // current level
    field int customerTimer;     // timer for spawning customers
    field boolean gameOver;      // game over flag
    field boolean firstMove;     // tracks if player made first move
    field int actionCooldown;    // cooldown timer to prevent action spam
    field LevelConfig levelConfig; // level configuration
    field int hearts;            // remaining hearts (lives)
    field int levelGoal;         // customers to serve for this level
    field int timeLimit;         // time limit for this level (in cycles)
    field int timeRemaining;     // time remaining (in cycles)
    field int pairThreshold;     // pair spawn threshold for this level
    field boolean levelWon;      // level completed successfully
    field boolean paused;        // game is paused
    
    /** Constructs a new Penguin Diner Game */
    constructor PenguinDinerGame new(int currentLevel, LevelConfig config, Shop playerShop) {
        var int i;
        var Table table;
        
        let level = currentLevel;
        let levelConfig = config;
        
        // Get level-specific configuration
        let hearts = config.getHearts(level);
        
        // Add extra heart if purchased
        if (playerShop.getExtraHeartBought()) {
            let hearts = hearts + 1;
        }
        
        let levelGoal = config.getGoal(level);
        let timeLimit = config.getTimeLimit(level);
        let timeRemaining = timeLimit;
        let numTables = config.getTables(level);
        let maxCustomers = config.getMaxCustomers(level);
        let pairThreshold = config.getPairThreshold(level);
        
        // Initialize game state
        let penguin = Penguin.new(250, 200);
        
        // Apply speed upgrades to penguin
        do penguin.setSpeedUpgrades(playerShop.getSpeedUpgrades());
        
        let numCustomers = 0;
        let totalCustomersServed = 0;
        let score = 0;  // Score is now money earned this level
        let customerTimer = GameConfig.getInitialCustomerTimer();
        let gameOver = false;
        let firstMove = false;
        let actionCooldown = 0;
        let levelWon = false;
        let paused = false;
        
        // Create tables array (flexible configuration) - tables closer together
        let tables = Array.new(6);  // Max 6 tables
        if (numTables = 2) {
            let tables[0] = Table.new(200, 120, 0);
            let tables[1] = Table.new(310, 120, 1);
        }
        if (numTables = 3) {
            let tables[0] = Table.new(160, 120, 0);
            let tables[1] = Table.new(256, 120, 1);
            let tables[2] = Table.new(352, 120, 2);
        }
        if (numTables = 4) {
            let tables[0] = Table.new(180, 100, 0);
            let tables[1] = Table.new(330, 100, 1);
            let tables[2] = Table.new(180, 140, 2);
            let tables[3] = Table.new(330, 140, 3);
        }
        if (numTables = 5) {
            let tables[0] = Table.new(140, 90, 0);
            let tables[1] = Table.new(256, 90, 1);
            let tables[2] = Table.new(372, 90, 2);
            let tables[3] = Table.new(198, 150, 3);
            let tables[4] = Table.new(314, 150, 4);
        }
        if (numTables = 6) {
            let tables[0] = Table.new(140, 80, 0);
            let tables[1] = Table.new(256, 80, 1);
            let tables[2] = Table.new(372, 80, 2);
            let tables[3] = Table.new(140, 160, 3);
            let tables[4] = Table.new(256, 160, 4);
            let tables[5] = Table.new(372, 160, 5);
        }
        
        // Create customers array
        let customers = Array.new(maxCustomers);
        let i = 0;
        while (i < maxCustomers) {
            let customers[i] = null;
            let i = i + 1;
        }
        
        // Create kitchen with slots matching number of tables
        let kitchen = Kitchen.new(GameConfig.getKitchenX(), GameConfig.getKitchenY(), numTables);
        
        // Apply cooking upgrades
        do kitchen.setCookingUpgrades(playerShop.getCookingUpgrades());
        
        // Draw kitchen after creation
        do kitchen.draw();
        
        // Draw UI
        do drawUI();
        
        return this;
    }
    
    /** Disposes this game */
    method void dispose() {
        var int i;
        var Table table;
        var Customer customer;
        
        do penguin.dispose();
        
        // Dispose tables
        let i = 0;
        while (i < numTables) {
            let table = tables[i];
            do table.dispose();
            let i = i + 1;
        }
        do tables.dispose();
        
        // Dispose customers
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                do customer.dispose();
            }
            let i = i + 1;
        }
        do customers.dispose();
        
        // Dispose kitchen
        do kitchen.dispose();
        
        do Memory.deAlloc(this);
        return;
    }
    
    /** Draws the UI elements */
    method void drawUI() {
        do Output.moveCursor(0, 0);
        do Output.printString("Lv");
        do Output.printInt(level);
        do Output.moveCursor(0, 7);
        do Output.printString("Goal:");
        do Output.printInt(levelGoal);
        do Output.moveCursor(0, 16);
        do Output.printString("Served:");
        do Output.printInt(totalCustomersServed);
        do Output.moveCursor(0, 27);
        do Output.printString("$");
        do Output.printInt(score);
        do Output.moveCursor(0, 36);
        do Output.printString("Hearts:");
        do Output.printInt(hearts);
        do Output.moveCursor(0, 47);
        do Output.printString("Time:");
        do drawTime();
        do Output.moveCursor(1, 0);
        do Output.printString("Controls: Arrows=Move, P=Pause, Q=Quit");
        
        // Show ready message
        do Output.moveCursor(10, 20);
        do Output.printString("*** READY TO PLAY! ***");
        do Output.moveCursor(11, 18);
        do Output.printString("Move near to interact!");
        
        return;
    }
    
    /** Draws the time remaining in seconds */
    method void drawTime() {
        var int seconds;
        let seconds = timeRemaining / 25;  // Convert cycles to seconds (40ms * 25 = 1 second)
        do Output.printInt(seconds);
        do Output.printString("s   ");
        return;
    }
    
    /** Updates the display */
    method void updateDisplay() {
        do Output.moveCursor(0, 12);
        do Output.printInt(levelGoal);
        do Output.printString(" ");
        do Output.moveCursor(0, 23);
        do Output.printInt(totalCustomersServed);
        do Output.printString(" ");
        do Output.moveCursor(0, 28);
        do Output.printInt(score);
        do Output.printString("  ");
        do Output.moveCursor(0, 43);
        do Output.printInt(hearts);
        do Output.printString(" ");
        do Output.moveCursor(0, 52);
        do drawTime();
        return;
    }
    
    /** Gets money earned this level */
    method int getMoney() {
        // Ensure money never goes negative
        if (score < 0) {
            return 0;
        }
        return score;
    }
    
    /** Spawns new customer(s) - sometimes pairs */
    method void spawnCustomer() {
        var int i, queuePos, queueY, checkPos, rand, slot1;
        var Customer customer;
        var Array queuePositions;
        var boolean isPair, foundSlot1;
        
        // Decide if this is a pair - using level-specific threshold
        let rand = (customerTimer + penguin.getX() + penguin.getY()) - (((customerTimer + penguin.getX() + penguin.getY()) / GameConfig.getPairRandomPrime()) * GameConfig.getPairRandomPrime());
        let isPair = rand < pairThreshold;
        
        // Only spawn if there's space
        if (numCustomers < maxCustomers) {
            // Create array to track which queue positions are taken
            let queuePositions = Array.new(maxCustomers);
            let i = 0;
            while (i < maxCustomers) {
                let queuePositions[i] = 0;  // 0 = free, 1 = taken
                let i = i + 1;
            }
            
            // Mark taken queue positions
            let i = 0;
            while (i < maxCustomers) {
                let customer = customers[i];
                if (~(customer = null)) {
                    if (customer.getState() = 0) {  // waiting in queue
                        let checkPos = customer.getQueuePosition();
                        if ((checkPos > -1) & (checkPos < maxCustomers)) {
                            let queuePositions[checkPos] = 1;  // mark as taken
                        }
                    }
                }
                let i = i + 1;
            }
            
            // Find first free queue position
            let queuePos = 0;
            let foundSlot1 = false;
            
            while (queuePos < maxCustomers) {
                if (queuePositions[queuePos] = 0) {
                    let queueY = GameConfig.getQueueStartY() + (queuePos * GameConfig.getQueueSpacing());
                    
                    // Find empty customer slot
                    let i = 0;
                    while ((i < maxCustomers) & (~foundSlot1)) {
                        if (customers[i] = null) {
                            let slot1 = i;
                            let foundSlot1 = true;
                        }
                        let i = i + 1;
                    }
                    
                    if (foundSlot1) {
                        // Create customer (solo or pair)
                        let customer = Customer.new(GameConfig.getQueueX(), queueY, 0, isPair);
                        do customer.setQueuePosition(queuePos);
                        let customers[slot1] = customer;
                        let numCustomers = numCustomers + 1;
                        
                        do updateDisplay();
                        let queuePos = maxCustomers;  // exit
                    }
                }
                let queuePos = queuePos + 1;
            }
            
            do queuePositions.dispose();
        }
        return;
    }
    
    /** Check if penguin is near a position */
    method boolean isNear(int targetX, int targetY) {
        var int dx, dy, nearDist;
        let nearDist = GameConfig.getNearDistance();
        let dx = penguin.getX() - targetX;
        let dy = penguin.getY() - targetY;
        
        if (dx < 0) {
            let dx = -dx;
        }
        if (dy < 0) {
            let dy = -dy;
        }
        
        return (dx < nearDist) & (dy < nearDist);
    }
    
    /** REMOVED - customers no longer move when someone is seated */
    method void updateQueue() {
        // Do nothing - customers stay in their positions
        return;
    }
    
    /** Handle seating action - seats customers at table */
    method void handleSeat() {
        var int i, dx, dy, dist, minDist, nearestCustomerIndex;
        var Customer customer, nearestCustomer;
        var Table table;
        var int tableId, nearDist;
        var boolean foundCustomer;
        
        let minDist = 10000;  // Large number
        let nearestCustomerIndex = -1;
        let foundCustomer = false;
        let nearDist = GameConfig.getNearDistance();
        
        // Find the NEAREST waiting customer within range
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                if (customer.getState() = 0) {
                    let dx = penguin.getX() - customer.getX();
                    let dy = penguin.getY() - customer.getY();
                    if (dx < 0) { let dx = -dx; }
                    if (dy < 0) { let dy = -dy; }
                    
                    if ((dx < nearDist) & (dy < nearDist)) {
                        let dist = dx + dy;
                        if (dist < minDist) {
                            let minDist = dist;
                            let nearestCustomerIndex = i;
                            let foundCustomer = true;
                        }
                    }
                }
            }
            let i = i + 1;
        }
        
        // If we found a nearby customer, seat them
        if (foundCustomer) {
            let nearestCustomer = customers[nearestCustomerIndex];
            
            // Find first empty table
            let tableId = 0;
            while (tableId < numTables) {
                let table = tables[tableId];
                if (~(table.isOccupied())) {
                    do table.seatCustomer(nearestCustomer);
                    
                    // Position customer based on type
                    if (nearestCustomer.getIsPair()) {
                        // Pair sits at table center
                        do nearestCustomer.moveTo(table.getX(), table.getY());
                    } else {
                        // Solo sits on left or right chair (50/50 random using timer)
                        if ((customerTimer - ((customerTimer / 2) * 2)) = 0) {
                            // Even timer = left chair
                            do nearestCustomer.setSitsOnLeft(true);
                            do nearestCustomer.moveTo(table.getX() - 20, table.getY());
                        } else {
                            // Odd timer = right chair
                            do nearestCustomer.setSitsOnLeft(false);
                            do nearestCustomer.moveTo(table.getX() + 20, table.getY());
                        }
                    }
                    
                    do nearestCustomer.seat();
                    do updateQueue();
                    do redrawAll();
                    let tableId = numTables; // exit
                }
                let tableId = tableId + 1;
            }
        }
        
        return;
    }
    
    /** Handle take order action - takes orders from pairs (2 meals) or solo (1 meal) */
    method void handleTakeOrder() {
        var int i, foodType, foodType2;
        var Customer customer;
        
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                if (customer.getState() = 1) {
                    if (isNear(customer.getX(), customer.getY())) {
                        // Random food selection (0, 1, or 2) using prime mod 7 and penguin position
                        let foodType = (customerTimer + penguin.getX() + i) - (((customerTimer + penguin.getX() + i) / 7) * 7);
                        if (foodType > 2) {
                            let foodType = foodType - ((foodType / 3) * 3);  // Map to 0-2
                        }
                        
                        // Assign food type and change state
                        do customer.setFoodType(foodType);
                        do customer.takeOrder();
                        
                        // Send order to kitchen
                        do kitchen.addOrder(foodType);
                        
                        // If pair, order second meal too
                        if (customer.getIsPair()) {
                            // Different food for second meal using prime mod 11 and penguin Y
                            let foodType2 = (customerTimer + penguin.getY() + i) - (((customerTimer + penguin.getY() + i) / 11) * 11);
                            if (foodType2 > 2) {
                                let foodType2 = foodType2 - ((foodType2 / 3) * 3);  // Map to 0-2
                            }
                            do customer.setFoodType2(foodType2);
                            do kitchen.addOrder(foodType2);  // Will queue if kitchen full
                        }
                        
                        let i = maxCustomers; // exit
                    }
                }
            }
            let i = i + 1;
        }
        return;
    }
    
    /** Handle pickup food from kitchen (NEW!) */
    method void handlePickupFood() {
        var int slot, foodType, slotX, maxSlots, nearestSlot, minDist, dist;
        var boolean pickedUp, foundSlot;
        
        // Check if both hands are already full
        if (penguin.bothHandsFull()) {
            return;  // Can't pick up more!
        }
        
        let maxSlots = kitchen.getMaxSlots();
        let minDist = 10000;  // Large number
        let nearestSlot = -1;
        let foundSlot = false;
        
        // Find the NEAREST slot with ready food
        let slot = 0;
        while (slot < maxSlots) {
            let slotX = kitchen.getSlotX(slot);
            
            // Check if this slot has food ready
            if (kitchen.isSlotReady(slot)) {
                // Calculate distance to this slot
                let dist = penguin.getX() - slotX;
                if (dist < 0) { let dist = -dist; }
                
                // Check if penguin is near AND this is the nearest slot
                if (isNear(slotX, kitchen.getY() - 15)) {
                    if (dist < minDist) {
                        let minDist = dist;
                        let nearestSlot = slot;
                        let foundSlot = true;
                    }
                }
            }
            
            let slot = slot + 1;
        }
        
        // Only pickup from the NEAREST slot with ready food
        if (foundSlot) {
            let foodType = kitchen.pickupFood(nearestSlot);
            if (~(foodType = -1)) {
                let pickedUp = penguin.pickupOrder(foodType);
            }
        }
        
        return;
    }
    
    /** Handle serve food action - serve to ANY customer waiting for food */
    method void handleServe() {
        var int i;
        var Customer customer;
        var boolean served;
        
        if (penguin.getHasOrder()) {
            let served = false;
            
            let i = 0;
            while ((i < maxCustomers) & (~served)) {
                let customer = customers[i];
                if (~(customer = null)) {
                    // Check if customer is waiting for food (state 2)
                    if (customer.getState() = 2) {
                        if (isNear(customer.getX(), customer.getY())) {
                            // Serve food regardless of type
                            if (customer.getIsPair()) {
                                // Pair customer - serve to whichever meal slot is empty
                                if (~customer.isMeal1Served()) {
                                    do customer.serveFood(1);  // Serve meal 1
                                    do penguin.deliverOrder();
                                    do redrawAll();
                                    let served = true;
                                } else {
                                    if (~customer.isMeal2Served()) {
                                        do customer.serveFood(2);  // Serve meal 2
                                        do penguin.deliverOrder();
                                        do redrawAll();
                                        let served = true;
                                    }
                                }
                            } else {
                                // Solo customer - just serve
                                do customer.serveFood(0);  // 0 for solo (ignored)
                                do penguin.deliverOrder();
                                do redrawAll();
                                let served = true;
                            }
                        }
                    }
                }
                let i = i + 1;
            }
        }
        return;
    }
    
    /** Handle collect payment - collects from customer */
    method void handleCollect() {
        var int i;
        var Customer customer;
        var Table table;
        var int payment, tableId, customersCount;
        
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                if (customer.isReadyToLeave()) {
                    if (isNear(customer.getX(), customer.getY())) {
                        // Collect payment - pairs pay for 2 meals
                        let payment = customer.collectPayment();
                        if (customer.getIsPair()) {
                            // Pair pays double (2 meals)
                            let score = score + (payment * 2);
                            let customersCount = 2;
                        } else {
                            // Solo pays normal
                            let score = score + payment;
                            let customersCount = 1;
                        }
                        let totalCustomersServed = totalCustomersServed + customersCount;
                        
                        // Find and clear table
                        let tableId = 0;
                        while (tableId < numTables) {
                            let table = tables[tableId];
                            if (table.getCustomer() = customer) {
                                do table.erasePaymentIndicator();
                                do table.removeCustomer();
                                let tableId = numTables; // exit
                            }
                            let tableId = tableId + 1;
                        }
                        
                        // Remove customer from array
                        let customers[i] = null;
                        let numCustomers = numCustomers - 1;
                        
                        // Erase and dispose customer
                        do customer.erase();
                        do customer.dispose();
                        
                        do updateDisplay();
                        do redrawAll();
                        let i = maxCustomers; // exit
                    }
                }
            }
            let i = i + 1;
        }
        return;
    }
    
    /** Smart action - detects context and performs appropriate action */
    method void handleSmartAction() {
        var int i, slot, slotX, maxSlots;
        var Customer customer;
        var boolean actionTaken;
        
        let actionTaken = false;
        
        // Priority 1: Check if near customer ready to pay (state 4)
        let i = 0;
        while ((i < maxCustomers) & (~actionTaken)) {
            let customer = customers[i];
            if (~(customer = null)) {
                if (customer.isReadyToLeave()) {
                    if (isNear(customer.getX(), customer.getY())) {
                        do handleCollect();
                        let actionTaken = true;
                    }
                }
            }
            let i = i + 1;
        }
        
        // Priority 2: Check if near customer waiting for food (state 2) and has food
        if (~actionTaken) {
            if (penguin.getHasOrder()) {
                let i = 0;
                while ((i < maxCustomers) & (~actionTaken)) {
                    let customer = customers[i];
                    if (~(customer = null)) {
                        if (customer.getState() = 2) {
                            if (isNear(customer.getX(), customer.getY())) {
                                do handleServe();
                                let actionTaken = true;
                            }
                        }
                    }
                    let i = i + 1;
                }
            }
        }
        
        // Priority 3: Check if near kitchen with ready food (and hands not full)
        if (~actionTaken) {
            if (~(penguin.bothHandsFull())) {
                let maxSlots = kitchen.getMaxSlots();
                let slot = 0;
                while ((slot < maxSlots) & (~actionTaken)) {
                    let slotX = kitchen.getSlotX(slot);
                    if (isNear(slotX, kitchen.getY() - 15)) {
                        do handlePickupFood();
                        let actionTaken = true;
                    }
                    let slot = slot + 1;
                }
            }
        }
        
        // Priority 4: Check if near seated customer (state 1) - take order
        if (~actionTaken) {
            let i = 0;
            while ((i < maxCustomers) & (~actionTaken)) {
                let customer = customers[i];
                if (~(customer = null)) {
                    if (customer.getState() = 1) {
                        if (isNear(customer.getX(), customer.getY())) {
                            do handleTakeOrder();
                            let actionTaken = true;
                        }
                    }
                }
                let i = i + 1;
            }
        }
        
        // Priority 5: Check if near waiting customer (state 0) - seat them
        if (~actionTaken) {
            let i = 0;
            while ((i < maxCustomers) & (~actionTaken)) {
                let customer = customers[i];
                if (~(customer = null)) {
                    if (customer.getState() = 0) {
                        if (isNear(customer.getX(), customer.getY())) {
                            do handleSeat();
                            let actionTaken = true;
                        }
                    }
                }
                let i = i + 1;
            }
        }
        
        return;
    }
    
    /** Redraws all game elements - proper layering ensures food shows on tables */
    method void redrawAll() {
        var int i;
        var Table table;
        var Customer customer;
        
        // Layer 0: Redraw kitchen (bottom/background)
        do kitchen.draw();
        
        // Layer 1: Redraw all tables
        let i = 0;
        while (i < numTables) {
            let table = tables[i];
            do table.draw();
            let i = i + 1;
        }
        
        // Layer 2: Redraw all customers (without food in eating state)
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                do customer.draw();
            }
            let i = i + 1;
        }
        
        // Layer 2.5: Draw food ON TOP of tables (for eating customers)
        let i = 0;
        while (i < maxCustomers) {
            let customer = customers[i];
            if (~(customer = null)) {
                do customer.drawFood();
            }
            let i = i + 1;
        }
        
        // Layer 2.75: Draw payment indicators ($ above tables)
        let i = 0;
        while (i < numTables) {
            let table = tables[i];
            let customer = table.getCustomer();
            if (~(customer = null)) {
                if (customer.isReadyToLeave()) {
                    do table.drawPaymentIndicator();
                }
            }
            let i = i + 1;
        }
        
        // Layer 3: Redraw penguin (foreground - on top of everything)
        do penguin.draw();
        
        return;
    }
    
    /** Update game state */
    method void update() {
        var int i, j, tableId;
        var Customer customer, partner;
        var Table table;
        
        // Don't update anything if paused
        if (paused) {
            return;
        }
        
        // Update kitchen (food cooking)
        do kitchen.update();
        
        // Decrement action cooldown
        if (actionCooldown > 0) {
            let actionCooldown = actionCooldown - 1;
        }
        
        // Only spawn customers and countdown timer after player has moved
        if (firstMove) {
            // Countdown timer
            if (timeRemaining > 0) {
                let timeRemaining = timeRemaining - 1;
            } else {
                // Time's up!
                let gameOver = true;
            }
            
            // Update customer timer
            let customerTimer = customerTimer + 1;
            if (customerTimer > GameConfig.getCustomerSpawnInterval()) {
                do spawnCustomer();
                let customerTimer = 0;
            }
            
            // AUTO-ACTION: Check proximity and perform actions automatically (with cooldown)
            if (actionCooldown = 0) {
                do handleSmartAction();
                let actionCooldown = 5;  // 5 frame cooldown (~0.1 seconds)
            }
        }
        
        // Update all customers (only after game has started)
        if (firstMove) {
            let i = 0;
            while (i < maxCustomers) {
                let customer = customers[i];
                if (~(customer = null)) {
                    do customer.update();
                
                // Check if customer left angry (patience < 1)
                // IMPORTANT: State 3 (eating) is NEVER angry - eating always completes
                // Only states 0,1,2 (player-dependent) and state 4 (waiting too long) can be angry
                if (customer.leftAngry()) {
                    // State 3 is PROTECTED - never remove during eating
                    if (customer.getState() = 3) {
                        // Skip - customer is eating, will finish normally
                    } else {
                        // States 0,1,2,4 can leave when patience runs out
                        if ((customer.getState() < 3) | (customer.getState() = 4)) {
                            // Lose a heart (1 heart even for pairs)
                            let hearts = hearts - 1;
                            
                            // Clear table
                            let tableId = 0;
                            while (tableId < numTables) {
                                let table = tables[tableId];
                                if (table.getCustomer() = customer) {
                                    do table.removeCustomer();
                                    let tableId = numTables;
                                }
                                let tableId = tableId + 1;
                            }
                            
                            // If customer ordered food (state 2), cancel their orders in kitchen
                            if (customer.getState() = 2) {
                                do kitchen.cancelOrder(customer.getFoodType());
                                if (customer.getIsPair()) {
                                    do kitchen.cancelOrder(customer.getFoodType2());
                                }
                            }
                            
                            // Remove current customer from array
                            let customers[i] = null;
                            let numCustomers = numCustomers - 1;
                            
                            // Erase and dispose current customer
                            do customer.erase();
                            do customer.dispose();
                            
                            do updateDisplay();
                            do redrawAll();
                            
                            // Check if game over (out of hearts)
                            if (hearts < 1) {
                                let gameOver = true;
                            }
                        }
                    }
                }
            }
                let i = i + 1;
            }
        }
        
        // Check if level goal reached
        if (totalCustomersServed > (levelGoal - 1)) {
            let levelWon = true;
            let gameOver = true;
        }
        
        return;
    }
    
    /** Clears the ready message */
    method void clearReadyMessage() {
        // Clear the ready message lines
        do Output.moveCursor(10, 0);
        do Output.printString("                                                            ");
        do Output.moveCursor(11, 0);
        do Output.printString("                                                            ");
        // Redraw all game elements to restore anything the message might have covered
        do redrawAll();
        return;
    }
    
    /** Runs the game - returns true if level won, false if lost */
    method boolean run() {
        var char key;
        var boolean exit;
        
        let exit = false;
        
        while ((~exit) & (~gameOver)) {
            // Check for key press
            let key = Keyboard.keyPressed();
            
            // Handle keys and enable continuous movement
            if (key = 81) { let exit = true; }           // Q key - quit
            
            if (key = 80) {                              // P key - pause
                do showPauseScreen();
                while (~(Keyboard.keyPressed() = 0)) {
                    do Sys.wait(10);
                }
            }
            
            // Arrow keys - clear message on first use and move continuously
            if (key = 131) {                              // up arrow
                if (~firstMove) {
                    do clearReadyMessage();
                    let firstMove = true;
                }
                if (penguin.moveUp(tables, numTables, customers, maxCustomers)) {
                    do redrawAll();  // Full redraw ensures perfect layering
                }
            }
            if (key = 133) {                              // down arrow
                if (~firstMove) {
                    do clearReadyMessage();
                    let firstMove = true;
                }
                if (penguin.moveDown(tables, numTables, customers, maxCustomers)) {
                    do redrawAll();  // Full redraw ensures perfect layering
                }
            }
            if (key = 130) {                              // left arrow
                if (~firstMove) {
                    do clearReadyMessage();
                    let firstMove = true;
                }
                if (penguin.moveLeft(tables, numTables, customers, maxCustomers)) {
                    do redrawAll();  // Full redraw ensures perfect layering
                }
            }
            if (key = 132) {                              // right arrow
                if (~firstMove) {
                    do clearReadyMessage();
                    let firstMove = true;
                }
                if (penguin.moveRight(tables, numTables, customers, maxCustomers)) {
                    do redrawAll();  // Full redraw ensures perfect layering
                }
            }
            
            
            // Update game state
            do update();
            do Sys.wait(GameConfig.getGameLoopDelay());
        }
        
        return levelWon;  // Return true if level won, false otherwise
    }
    
    /** Shows pause screen and waits for ENTER to resume */
    method void showPauseScreen() {
        var char key;
        
        // Set paused flag to stop all updates
        let paused = true;
        
        // Draw pause overlay
        do Output.moveCursor(10, 24);
        do Output.printString("*** PAUSED ***");
        do Output.moveCursor(11, 17);
        do Output.printString("Press ENTER to resume");
        
        // Wait for ENTER key to resume
        let key = 0;
        while (~(key = 128)) {  // 128 = ENTER key
            let key = Keyboard.keyPressed();
            do Sys.wait(50);
        }
        
        // Clear paused flag to resume updates
        let paused = false;
        
        // Clear pause message
        do Output.moveCursor(10, 0);
        do Output.printString("                                                            ");
        do Output.moveCursor(11, 0);
        do Output.printString("                                                            ");
        
        // Redraw everything to restore game state
        do redrawAll();
        
        return;
    }
}
